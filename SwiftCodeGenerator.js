// Generated by CoffeeScript 1.11.1
(function() {
  var SwiftCodeGenerator, addslashes;

  (function(root) {
    var ref;
    if ((ref = root.bundle) != null ? ref.minApiVersion('0.2.0') : void 0) {
      root.URI = require("./URI");
      return root.Mustache = require("./mustache");
    } else {
      require("URI.min.js");
      return require("mustache.js");
    }
  })(this);

  addslashes = function(str) {
    return ("" + str).replace(/[\\"]/g, '\\$&').replace(/(?:\r)/g, '\\r').replace(/(?:\n)/g, '\\n');
  };

  SwiftCodeGenerator = function() {
    this.url = function(request) {
      var name, url_params, url_params_object, value;
      url_params_object = (function() {
        var _uri;
        _uri = URI(request.url);
        return _uri.search(true);
      })();
      url_params = (function() {
        var results;
        results = [];
        for (name in url_params_object) {
          value = url_params_object[name];
          results.push({
            "name": addslashes(name),
            "value": addslashes(value)
          });
        }
        return results;
      })();
      return {
        "base": addslashes((function() {
          var _uri;
          _uri = URI(request.url);
          _uri.search("");
          return _uri;
        })()),
        "params": url_params,
        "has_params": url_params.length > 0
      };
    };
    this.headers = function(request) {
      var header_name, header_value, headers;
      headers = request.headers;
      return {
        "has_headers": Object.keys(headers).length > 0,
        "header_list": (function() {
          var results;
          results = [];
          for (header_name in headers) {
            header_value = headers[header_name];
            results.push({
              "header_name": addslashes(header_name),
              "header_value": addslashes(header_value)
            });
          }
          return results;
        })()
      };
    };
    this.body = function(request) {
      var json_body, name, raw_body, url_encoded_body, value;
      json_body = request.jsonBody;
      if (json_body) {
        return {
          "has_json_body": true,
          "json_body_object": this.json_body_object(json_body, 1)
        };
      }
      url_encoded_body = request.urlEncodedBody;
      if (url_encoded_body) {
        return {
          "has_url_encoded_body": true,
          "url_encoded_body": (function() {
            var results;
            results = [];
            for (name in url_encoded_body) {
              value = url_encoded_body[name];
              results.push({
                "name": addslashes(name),
                "value": addslashes(value)
              });
            }
            return results;
          })()
        };
      }
      raw_body = request.body;
      if (raw_body) {
        if (raw_body.length < 5000) {
          return {
            "has_raw_body": true,
            "raw_body": addslashes(raw_body)
          };
        } else {
          return {
            "has_long_body": true
          };
        }
      }
    };
    this.json_body_object = function(object, indent) {
      var indent_str, indent_str_children, key, s, value;
      if (indent == null) {
        indent = 0;
      }
      if (object === null) {
        s = "NSNull()";
      } else if (typeof object === 'string') {
        s = "\"" + (addslashes(object)) + "\"";
      } else if (typeof object === 'number') {
        s = "" + object;
      } else if (typeof object === 'boolean') {
        s = "" + (object ? "true" : "false");
      } else if (typeof object === 'object') {
        indent_str = Array(indent + 2).join('    ');
        indent_str_children = Array(indent + 3).join('    ');
        if (object.length != null) {
          s = "[\n" + ((function() {
            var i, len, results;
            results = [];
            for (i = 0, len = object.length; i < len; i++) {
              value = object[i];
              results.push("" + indent_str_children + (this.json_body_object(value, indent + 1)));
            }
            return results;
          }).call(this)).join(',\n') + ("\n" + indent_str + "]");
        } else {
          s = "[\n" + ((function() {
            var results;
            results = [];
            for (key in object) {
              value = object[key];
              results.push(indent_str_children + "\"" + (addslashes(key)) + "\": " + (this.json_body_object(value, indent + 1)));
            }
            return results;
          }).call(this)).join(',\n') + ("\n" + indent_str + "]");
        }
      }
      if (indent <= 1) {
        s = "let bodyObject: [String : Any] = " + s;
      }
      return s;
    };
    this.generate = function(context) {
      var request, template, view;
      request = context.getCurrentRequest();
      view = {
        "request": context.getCurrentRequest(),
        "url": this.url(request),
        "headers": this.headers(request),
        "body": this.body(request)
      };
      if (view.url.has_params || (view.body && view.body.has_url_encoded_body)) {
        view["has_utils_query_string"] = true;
      }
      template = readFile("swift.mustache");
      return Mustache.render(template, view);
    };
  };

  SwiftCodeGenerator.identifier = "com.codedbydan.PawExtensions.SwiftCodeGenerator";

  SwiftCodeGenerator.title = "Swift";

  SwiftCodeGenerator.fileExtension = "swift";

  SwiftCodeGenerator.languageHighlighter = "swift";

  registerCodeGenerator(SwiftCodeGenerator);

}).call(this);
